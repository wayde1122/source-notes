# Agent 核心引擎（agent/loop.py）

这是整个框架最关键的文件，约 474 行，实现了完整的 ReAct（推理-行动-观察）循环。

## AgentLoop 类

### 初始化

```python
class AgentLoop:
    def __init__(self, bus, provider, workspace, model, max_iterations=20,
                 memory_window=50, brave_api_key=None, exec_config=None,
                 cron_service=None, restrict_to_workspace=False, session_manager=None):
```

接收所有外部依赖，内部创建：
- `ContextBuilder` — 上下文构建器
- `SessionManager` — 会话管理
- `ToolRegistry` — 工具注册表（注册 9 个默认工具）
- `SubagentManager` — 子 Agent 管理器

### 默认注册的 9 个工具

| 工具名       | 类            | 功能             |
| ------------ | ------------- | ---------------- |
| read_file    | ReadFileTool  | 读取文件         |
| write_file   | WriteFileTool | 写入文件         |
| edit_file    | EditFileTool  | 编辑文件（替换） |
| list_dir     | ListDirTool   | 列出目录         |
| exec         | ExecTool      | 执行 Shell 命令  |
| web_search   | WebSearchTool | Brave 搜索       |
| web_fetch    | WebFetchTool  | 网页抓取         |
| message      | MessageTool   | 发送消息到渠道   |
| spawn        | SpawnTool     | 派生子 Agent     |
| cron         | CronTool      | 定时任务管理     |

## 主循环（run）

```python
async def run(self):
    while self._running:
        msg = await asyncio.wait_for(self.bus.consume_inbound(), timeout=1.0)
        response = await self._process_message(msg)
        if response:
            await self.bus.publish_outbound(response)
```

无限循环，每秒检查入站队列。出错时发送错误消息而非崩溃。

## 核心处理流程（_process_message）

### 第 1 步：系统消息分流

子 Agent 完成后的汇报消息（`channel == "system"`）走独立处理路径。

### 第 2 步：会话与斜杠命令

- 通过 `session_key`（格式：`channel:chat_id`）获取或创建会话
- `/new` — 压缩记忆后清空会话
- `/help` — 返回帮助信息

### 第 3 步：记忆压缩

当 `len(session.messages) > memory_window`（默认 50）时自动触发。

### 第 4 步：更新工具上下文

为 `message` / `spawn` / `cron` 工具设置当前的 channel 和 chat_id。

### 第 5 步：构建上下文

```python
messages = self.context.build_messages(
    history=session.get_history(),
    current_message=msg.content,
    media=msg.media,
    channel=msg.channel,
    chat_id=msg.chat_id,
)
```

### 第 6 步：Agent 循环（最多 20 次）

```python
while iteration < self.max_iterations:
    response = await self.provider.chat(messages, tools, model)

    if response.has_tool_calls:
        # 添加 assistant 消息 + 工具调用
        # 执行每个工具
        # 添加反思提示："Reflect on the results and decide next steps."
    else:
        final_content = response.content
        break
```

**关键设计：Interleaved CoT（交织思维链）** — 每次工具执行后追加一条 user 角色的反思提示，引导 LLM 在下一轮调用前先思考。

### 第 7 步：保存与返回

将 user 和 assistant 消息存入 session（包括 `tools_used` 列表），返回 OutboundMessage。

## 记忆压缩（_consolidate_memory）

用 LLM 将旧消息压缩为两部分：

```python
prompt = """Return a JSON with:
1. "history_entry": 2-5 句话的事件摘要，带时间戳
2. "memory_update": 更新后的长期记忆内容
"""
```

- `history_entry` → 追加到 `HISTORY.md`（可 grep 搜索的时间线）
- `memory_update` → 覆盖写入 `MEMORY.md`（长期事实）
- 压缩后保留最近 `keep_count` 条消息（`memory_window / 2`，至少 2 条，最多 10 条）

## 直接调用入口（process_direct）

CLI 和 Cron 使用，绕过 MessageBus 直接处理：

```python
async def process_direct(self, content, session_key="cli:direct", channel="cli", chat_id="direct"):
    msg = InboundMessage(channel=channel, sender_id="user", chat_id=chat_id, content=content)
    response = await self._process_message(msg, session_key=session_key)
    return response.content if response else ""
```
