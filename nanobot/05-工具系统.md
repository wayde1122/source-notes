# 工具系统（agent/tools/）

## 工具基类（base.py）

每个工具继承 `Tool` ABC，必须定义 4 个成员：

```python
class Tool(ABC):
    @property
    def name(self) -> str: ...        # 工具名称
    @property
    def description(self) -> str: ... # 工具描述
    @property
    def parameters(self) -> dict: ... # JSON Schema 参数定义
    async def execute(self, **kwargs) -> str: ... # 异步执行
```

### 内置功能

- **参数校验**：`validate_params()` 递归校验 JSON Schema（类型、枚举、范围、长度、必填字段）
- **格式转换**：`to_schema()` 自动转为 OpenAI function calling 格式

---

## 工具注册表（registry.py）

```python
class ToolRegistry:
    def register(self, tool: Tool): ...
    def unregister(self, name: str): ...
    def get_definitions(self) -> list[dict]: ...  # 所有工具的 OpenAI 格式
    async def execute(self, name, params) -> str: ...
```

`execute` 的错误处理策略：校验失败或执行异常都返回错误字符串（而非抛异常），让 LLM 能看到并自行修正。

---

## 各工具详解

### 文件操作工具（filesystem.py）

| 工具       | 参数                     | 行为                           |
| ---------- | ------------------------ | ------------------------------ |
| read_file  | path                     | 读取文件内容                   |
| write_file | path, content            | 写入文件（自动创建父目录）     |
| edit_file  | path, old_text, new_text | 精确替换（要求 old_text 唯一） |
| list_dir   | path                     | 列出目录（带文件/文件夹图标） |

**安全机制**：所有文件工具支持 `allowed_dir` 参数，启用后限制只能访问工作空间目录。

**edit_file 的唯一性保护**：

```python
count = content.count(old_text)
if count > 1:
    return "Warning: old_text appears {count} times. Please provide more context."
```

### Shell 执行工具（shell.py）

**多层安全防护**：

1. **正则黑名单**：拦截 `rm -rf`、`format`、`dd`、`shutdown`、fork bomb 等
2. **路径遍历检测**：检查 `../` 路径
3. **工作空间限制**：检测命令中的绝对路径是否超出工作空间
4. **超时控制**：默认 60 秒，超时自动 kill
5. **输出截断**：超过 10000 字符时截断

```python
deny_patterns = [
    r"\brm\s+-[rf]{1,2}\b",        # rm -rf
    r"\b(format|mkfs|diskpart)\b",  # 磁盘操作
    r"\bdd\s+if=",                  # dd 命令
    r"\b(shutdown|reboot)\b",       # 电源操作
    r":\(\)\s*\{.*\};\s*:",        # fork bomb
]
```

### Web 工具（web.py）

**web_search** — Brave Search API：
- 最多 10 条结果，返回标题 + URL + 描述
- 需要配置 `BRAVE_API_KEY`

**web_fetch** — 网页内容提取：
- 使用 `readability-lxml` 提取正文
- 支持 markdown / text 两种输出模式
- 内置 HTML → Markdown 的轻量转换（链接、标题、列表）
- URL 校验（只允许 http/https）、重定向限制（最多 5 次）

### 消息工具（message.py）

通过 `send_callback`（即 `bus.publish_outbound`）向渠道发送消息。

每次处理消息时 `set_context()` 更新默认 channel / chat_id，使 Agent 可不指定目标直接回复当前用户。

### 子 Agent 派生（spawn.py + subagent.py）

**SpawnTool** 是 LLM 调用的入口，委托给 **SubagentManager** 执行。

子 Agent 的关键设计：

| 特性         | 说明                                          |
| ------------ | --------------------------------------------- |
| 隔离的工具集 | 只有文件 / Shell / Web，没有 message / spawn   |
| 防递归       | 子 Agent 不能再派生子 Agent                    |
| 异步后台     | `asyncio.create_task` 不阻塞主 Agent           |
| 结果汇报     | 通过 MessageBus 发送 `channel="system"` 消息   |
| 迭代上限     | 最多 15 次（主 Agent 是 20 次）                |
| 独立系统提示 | 专注任务完成，不继承主 Agent 的完整上下文      |

### 定时任务工具（cron.py）

支持 3 种操作 + 3 种调度模式：

**操作**：`add` / `list` / `remove`

**调度模式**：

| 模式           | 参数          | 示例                         |
| -------------- | ------------- | ---------------------------- |
| every（周期）  | every_seconds | 每 3600 秒                   |
| cron（表达式） | cron_expr     | `"0 9 * * *"`（每天 9 点）   |
| at（一次性）   | at            | `"2026-03-01T10:00:00"`      |

一次性任务（`at`）执行后自动删除。
