# 总结与设计思考

## 设计亮点

### 1. 极致轻量

约 4000 行 Python 代码实现了完整的多渠道 AI Agent 框架。对比主流 Agent 框架动辄数万行，nanobot 做到了"够用即可"的极简主义。

### 2. 事件驱动解耦

MessageBus（两条 asyncio.Queue）将渠道层与 Agent 层完全解耦。好处：
- 添加渠道不需要改 Agent
- 渠道之间互不影响
- 子 Agent 的结果汇报也走同一条消息总线

### 3. 注册表驱动的扩展

三个扩展点都用注册表模式，新增只需"注册一个条目"：
- 添加工具：继承 `Tool` → 注册到 `ToolRegistry`
- 添加提供商：添加 `ProviderSpec` → 添加配置字段
- 添加渠道：继承 `BaseChannel` → 在 `ChannelManager._init_channels` 添加

### 4. 渐进式技能加载

不把所有技能内容塞进系统提示（浪费 token），而是：
- 系统提示中只放摘要
- Agent 需要时通过 `read_file` 按需加载
- 节省约 50-80% 的技能相关 token 消耗

### 5. 双层记忆 + LLM 自动压缩

- MEMORY.md：长期事实（全量注入上下文）
- HISTORY.md：时间线日志（Agent 通过 grep 搜索）
- 会话超长时 LLM 自动压缩，无需人工干预

### 6. 纯文件存储

不依赖任何数据库：
- 配置：JSON
- 会话：JSONL（一行一条消息，支持增量追加）
- 记忆：Markdown（人类可读可编辑）
- 定时任务：JSON

好处：零运维、可版本控制、人类可直接查看和修改。

### 7. 安全防护

Shell 工具的多层防护值得学习：
- 正则黑名单拦截危险命令
- 路径遍历检测
- 工作空间沙箱限制
- 超时强制 kill
- 输出截断

---

## 设计取舍

### 文件存储 vs 数据库

**选择**：纯文件存储

**好处**：零依赖、便于调试、可人工编辑

**代价**：
- 并发写入安全性不如数据库
- 大量会话时性能下降（无索引）
- 无事务保证

**适用场景**：个人助手（低并发），不适合多用户高并发场景。

### 同步消息处理 vs 异步并发

**选择**：单 Agent 串行处理

AgentLoop 每次只处理一条消息。收到多条消息时排队等待。

**好处**：简单、无并发冲突

**代价**：多渠道同时来消息时响应延迟

### LiteLLM 统一 vs 各提供商独立实现

**选择**：LiteLLM 统一接入

**好处**：一套代码支持 100+ 模型，新提供商只需加一个 ProviderSpec

**代价**：依赖 LiteLLM 库的维护质量，某些提供商的特殊功能可能不支持

---

## 可借鉴的模式

### 对 Agent 框架的参考价值

1. **ReAct 循环 + Interleaved CoT**：每次工具执行后加入反思提示，比纯 ReAct 效果更好
2. **子 Agent 隔离**：限制工具集防递归，异步执行 + 消息总线汇报
3. **记忆压缩**：用 LLM 自己来压缩历史，比规则压缩更智能
4. **渐进式技能加载**：摘要 + 按需读取，平衡上下文长度和能力

### 对多渠道系统的参考价值

1. **统一消息格式**：InboundMessage / OutboundMessage 抽象了平台差异
2. **延迟导入 + 优雅降级**：缺少 SDK 不影响其他渠道
3. **模板方法**：_handle_message() 统一权限检查和消息封装
4. **去重策略**：deque / OrderedDict 做本地消息 ID 去重

### 对配置系统的参考价值

1. **Pydantic BaseSettings + 环境变量**：支持文件 + 环境变量双重配置
2. **camelCase / snake_case 自动转换**：对外 camelCase（JSON 友好），对内 snake_case（Python 惯例）
3. **提供商自动匹配**：通过模型名关键字 + API Key 前缀 + API Base 关键字多维匹配

---

## 阅读建议

如果你也想阅读 nanobot 源码，推荐顺序：

```
01. __main__.py / cli/commands.py  → 理解入口和系统编排
02. bus/events.py + queue.py       → 理解组件解耦方式
03. agent/loop.py                  → 最核心，理解 ReAct 循环
04. agent/context.py + memory.py   → 理解提示词工程
05. agent/tools/*                  → 理解 Agent 能力
06. channels/base.py + manager.py  → 理解多平台接入
07. providers/registry.py          → 理解提供商管理
```

每个阶段关注：这个模块解决什么问题？对外暴露什么接口？内部如何实现？
