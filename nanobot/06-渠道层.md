# 渠道层（channels/）

## BaseChannel 抽象接口（base.py）

所有渠道必须实现的合约：

```python
class BaseChannel(ABC):
    name: str = "base"

    async def start(self) -> None: ...              # 连接平台，开始监听
    async def stop(self) -> None: ...               # 停止并清理
    async def send(self, msg: OutboundMessage): ... # 发送消息
    def is_allowed(self, sender_id: str) -> bool: ... # 权限检查（非抽象）
```

### 权限控制

- `allow_from` 列表为空 → 允许所有人
- 不为空 → 只允许列表中的用户
- 支持 `id|username` 格式的复合标识符（如 Telegram 的 `123456|john`）

### 消息处理模板（_handle_message）

```python
async def _handle_message(self, sender_id, chat_id, content, media=None, metadata=None):
    if not self.is_allowed(sender_id):
        logger.warning(f"Access denied for {sender_id}")
        return
    msg = InboundMessage(channel=self.name, sender_id=sender_id, ...)
    await self.bus.publish_inbound(msg)
```

所有渠道共享这个入口流程，只需在各自的消息回调中调用 `_handle_message`。

---

## ChannelManager（manager.py）

### 初始化策略

延迟导入 + try/except，缺少 SDK 时优雅降级：

```python
if config.channels.telegram.enabled:
    try:
        from nanobot.channels.telegram import TelegramChannel
        self.channels["telegram"] = TelegramChannel(config, bus)
    except ImportError as e:
        logger.warning(f"Telegram not available: {e}")
```

### 出站分发

独立协程从出站队列取消息，按 `msg.channel` 路由到对应渠道的 `send()` 方法。

---

## 9 个渠道实现对比

| 渠道     | SDK                 | 连接方式          | 需要公网 IP | 多媒体       | 输入指示    |
| -------- | ------------------- | ----------------- | ----------- | ------------ | ----------- |
| Telegram | python-telegram-bot | Long Polling      | 否          | 图/语音/文件 | typing 循环 |
| WhatsApp | Baileys (Node.js)   | WebSocket Bridge  | 否          | 通过桥接     | 无          |
| Discord  | 原生 WebSocket      | Gateway WebSocket | 否          | DM/频道      | 无          |
| Slack    | slack-sdk           | Socket Mode       | 否          | 群组/DM      | 无          |
| 飞书     | lark-oapi           | WebSocket         | 否          | 文本为主     | 表情反应    |
| 钉钉     | dingtalk-stream     | Stream Mode       | 否          | 文本         | 无          |
| QQ       | qq-botpy            | WebSocket         | 否          | 仅私聊文本   | 无          |
| Email    | imaplib/smtplib     | IMAP Polling      | 否          | 文本         | 无          |
| Mochat   | python-socketio     | Socket.IO         | 否          | 群组/面板    | 无          |

### Telegram 渠道亮点

1. **Markdown → HTML 转换**：精细的正则处理，保护代码块，转换链接/粗体/斜体/列表
2. **typing 指示器**：收到消息后立即启动，每 4 秒发送一次，回复后停止
3. **语音转写**：语音/音频文件通过 Groq Whisper API 自动转为文字
4. **Fallback 机制**：HTML 解析失败时回退到纯文本发送

### 飞书渠道亮点

1. **跨线程桥接**：WebSocket 在独立线程运行，通过 `run_coroutine_threadsafe` 回到 asyncio
2. **Interactive Card**：Markdown 表格自动解析为飞书原生 table 组件
3. **表情反应**：收到消息后添加 THUMBSUP 表示"已收到"
4. **消息去重**：`OrderedDict` 缓存最近 1000 条 message_id

### QQ 渠道特点

1. **动态类生成**：`_make_bot_class()` 动态创建 botpy.Client 子类
2. **消息去重**：`deque(maxlen=1000)` 缓存 message_id
3. **自动重连**：连接断开后 5 秒自动重连
4. **仅私聊**：当前只支持 C2C 私聊消息

### WhatsApp 渠道特点

使用 Node.js 桥接（TypeScript + Baileys SDK）：
- Python 通过 WebSocket 与 Node.js 桥接通信
- 桥接在 `~/.nanobot/bridge/` 目录自动构建
- QR 码扫描认证
